(module spc-parser scheme
  (require parser-tools/yacc
           "spc-lex.ss"
           "spc-structures.ss")
  
  (define (spc-parser source)
    (parser
     (src-pos)
     
     (start program)
     (end EOF)
     
     (error (λ (tok-ok? tok-name tok-value start-pos end-pos)
              (printf "Error at (~s, ~s): Unexpected ~s ~s ~n" (position-line start-pos) (position-col start-pos) tok-name (tk-val tok-value))))
     
     (tokens keywords delim data eoftk)
     
     (suppress)
     ; (yacc-output "c.y")
     
     (grammar
      
      (program ((program-heading SC block DOT) $3))
      (program-heading ((PROGRAM ID) (tk-val $2))
                       ((PROGRAM ID LP id-list RP) (list (tk-val $2) $4)))
      
      
      ;; Block
      (block ((label-decls 
               const-defs 
               type-defs 
               var-decls 
               proc-func-decls 
               compound-statement) 
              (make-block $1 $2 $3 $4 $5 $6)))
      
      ;; Labels section
      (label-decls (() null)
                   ((LABEL label-list SC) $2))
      (label-list ((INT) (list $1))
                  ((INT COMMA label-list) (cons $1 $3)))
      
      ;; Constants section
      (const-defs (() null)
                  ((CONST const-def-list) $2))
      (const-def-list ((const-def) (list $1))
                      ((const-def const-def-list) (cons $1 $2)))
      (const-def ((ID EQ constant SC) (make-constant $1 $3)))
      (constant ((STRING) $1)
                ((ID) $1)
                ((signed-number) $1)
                ((sign ID) (list $1 $2)))
      
      ;; Types section
      (type-defs (() null)
                 ((TYPE type-def-list) (list 'types $2)))
      (type-def-list ((type-def) (list $1))
                     ((type-def type-def-list) (cons $1 $2)))
      (type-def ((ID EQ type-denoter SC) (list (tk-val $1) $3)))
      (type-denoter ((ID) (tk-val $1))
                    ((new-type) $1))
      (new-type ((new-ord-type) $1)
                ((new-struct-type) $1)
                ((new-pointer-type) $1))
      (new-ord-type ((enum-type) $1)
                    ((subrange-type) $1))
      ; Enum type
      (enum-type ((LP id-list RP) $2))
      ; Subrange type
      (subrange-type ((constant DDOT constant) (list 'range $1 $3)))
      (new-struct-type ((unpacked-struct-type) $1)
                       ((PACKED unpacked-struct-type) (list 'packed $2)))
      (unpacked-struct-type ((array-type) $1)
                            ((record-type) $1)
                            ((set-type) $1)
                            ((file-type) $1))
      ; Array type
      (array-type ((ARRAY LB ord-type-list RB OF type-denoter) (list 'array $3 $6)))
      (ord-type-list ((ord-type) (list $1))
                     ((ord-type COMMA ord-type-list) (cons $1 $3)))
      (ord-type ((new-ord-type) $1)
                ((ID) (tk-val $1)))
      ; Record type
      (record-type ((RECORD field-list END) (list 'record $2)))
      (field-list (() null)
                  ((variant-part) $1)
                  ((variant-part SC) $1)
                  ((fixed-part) $1)
                  ((fixed-part SC) $1)
                  ((fixed-part SC variant-part) (list $1 $3)))
      (fixed-part ((record-section) (list $1))
                  ((fixed-part SC record-section) (cons $3 $1)))
      (record-section ((id-list COLON type-denoter) (list $1 $3)))
      (variant-part ((CASE variant-selector OF variant-list*) (list 'variant $2 $4)))
      (variant-list* ((variant-list) $1)
                     ((variant-list SC) $1))
      (variant-list ((variant) (list $1))
                    ((variant-list SC variant) (cons $3 $1)))
      (variant ((const-list COLON LP field-list RP) (list $1 $4)))
      (const-list ((constant) (list $1))
                  ((constant COMMA const-list) (cons $1 $3)))
      (variant-selector ((ID) (tk-val $1))
                        ((ID COLON ID) (list (tk-val $1) (tk-val $3))))
      ; Set type
      (set-type ((SET OF ord-type) (list 'set $3)))
      ; File type
      (file-type ((FILE OF type-denoter) (list 'file $3)))
      ; Pointer type
      (new-pointer-type ((CARET ID) (list '^ $2)))
      
      ;; Var section
      (var-decls (() null)
                 ((VAR var-decl-list) (list 'vars $2)))
      (var-decl-list ((var-decl) (list $1))
                     ((var-decl var-decl-list) (cons $1 $2)))
      (var-decl ((id-list COLON type-denoter SC) (list $1 $3)))
      (var-access ((ID) (tk-val $1))
                  ((ID var-access-rest-list) (list (tk-val $1) $2)))
      (var-access-rest-list ((var-access-rest) (list $1))
                            ((var-access-rest var-access-rest-list) (cons $1 $2)))
      (var-access-rest ((LB expr-list RB) $2)
                       ((DOT ID) (list 'dot (tk-val $2)))
                       ((CARET) 'caret))
      
      ;; Procedures and Functions declarations
      (proc-func-decls (() null)
                       ((proc-decl proc-func-decls) (cons $1 $2))
                       ((func-decl proc-func-decls) (cons $1 $2)))
      (proc-decl ((proc-heading SC ID) (list 'proc $1 (tk-val $3)))
                 ((proc-heading SC block) (list 'proc $1 $3)))
      (proc-heading ((PROCEDURE ID formal-parameter-list) (list (tk-val $2) $3)))
      (formal-parameter-list (() null)
                             ((LP formal-parameter-section-list RP) $2))
      (formal-parameter-section-list ((formal-parameter-section) (list $1))
                                     ((formal-parameter-section SC formal-parameter-section-list) (cons $1 $3)))
      (formal-parameter-section ((value-parameter-spec) $1)
                                ((var-parameter-spec) $1)
                                ((proc-heading) $1)
                                ((func-heading) $1)
                                ((conformant-array-parameter-spec) $1))
      (value-parameter-spec ((id-list COLON ID) (list $1 (tk-val $3))))
      (var-parameter-spec ((VAR id-list COLON ID) (list 'var $2 (tk-val $4))))
      (conformant-array-parameter-spec ((value-conf-array-spec) $1)
                                       ((var-conf-array-spec) $1))
      (value-conf-array-spec ((id-list COLON conf-array-schema) (list $1 $3)))
      (var-conf-array-spec ((VAR id-list COLON conf-array-schema) (list 'var $2 $4)))
      (conf-array-schema ((packed-conf-array-schema) $1)
                         ((unpacked-conf-array-schema) $1))
      (packed-conf-array-schema ((PACKED ARRAY LB index-type-spec RB OF ID) (list 'packed $4 (tk-val $7))))
      (unpacked-conf-array-schema 
       ((ARRAY LB index-type-spec-list RB OF unpacked-conf-array-schema-specifier)
        (list 'array $3 $6)))
      (unpacked-conf-array-schema-specifier ((ID) (tk-val $1))
                                            ((conf-array-schema) $1))
      (index-type-spec-list ((index-type-spec) (list $1))
                            ((index-type-spec SC index-type-spec-list) (cons $1 $3)))
      (index-type-spec ((ID DDOT ID COLON ID) (list 'index (tk-val $1) (tk-val $3) (tk-val $5))))
      (func-decl ((func-heading SC ID) (list 'func $1 (tk-val $3)))
                 ((func-heading SC block) (list 'func $1 $3))
                 ((func-id SC block) (list 'func $1 $3)))
      (func-heading ((FUNCTION ID formal-parameter-list COLON ID) (list (tk-val $2) $3 (tk-val $5))))
      (func-id ((FUNCTION ID) (tk-val $2)))
      
      ;; Expressions
      (expr-list ((expr) (list $1))
                 ((expr COMMA expr-list) (cons $1 $3)))
      (factor ((ID var-access-rest) (list (tk-val $1) $2))
              ((ID LP expr-list RP) (list (tk-val $1) $3))
              ((unsigned-const) $1)
              ((set-constructor) $1)
              ((LP expr RP) $2)
              ((NOT factor) (list 'not $2)))
      (expr ((simple-expr)  $1)
            ((simple-expr relop simple-expr) (list $2 $1 $3)))
      (simple-expr ((term-list) $1)
                   ((sign term-list) (list $1 $2)))
      (term-list ((term) $1)
                 ((term addop term-list) (list $2 $1 $3)))
      (term ((factor) $1)
            ((factor multop term) (list $2 $1 $3)))
      (unsigned-const ((number) $1)
                      ((STRING) (tk-val $1))
                      ((ID) (tk-val $1))
                      ((NIL) 'nil))
      (set-constructor ((LB member-designator-list RB) $2)
                       ((LB RB) null))
      (member-designator-list ((member-designator) (list $1))
                              ((member-designator COMMA member-designator-list) (cons $1 $3)))
      (member-designator ((expr) $1)
                         ((expr DDOT expr) (list $1 $3)))
      (multop ((AST) '*)
              ((SLASH) '/)
              ((DIV) 'div)
              ((MOD) 'mod)
              ((AND) 'and))
      (addop ((PLUS) '+)
             ((MINUS) '-)
             ((OR) 'or))
      (relop ((EQ) '=)
             ((NOTEQ) '<>)
             ((LT) '<)
             ((GT) '>)
             ((LEQ) '<=)
             ((GEQ) '>=)
             ((IN) 'in))
      
      ;; Statements
      (simple-statement (() null)
                        ((assign-statement) $1)
                        ((proc-statement) $1)
                        ((goto-statement) $1))
      
      (assign-statement ((var-access ASSIGN expr) (list ':= $1 $3)))
      (goto-statement ((GOTO INT) (list 'goto (tk-val $2))))
      (proc-statement-arg ((expr) $1)
                          ((expr COLON expr) (list $1 $3))
                          ((expr COLON expr COLON expr) (list $1 $3 $5)))
      (proc-statement-arg-list 
       ((proc-statement-arg) (list $1))
       ((proc-statement-arg COMMA proc-statement-arg-list) (cons $1 $3)))
      (proc-statement ((ID) (tk-val $1))
                      ((ID LP proc-statement-arg-list RP) (list (tk-val $1) $3)))
      (struct-statement ((compound-statement) $1)
                        ((cond-statement) $1)
                        ((repetitive-statement) $1)
                        ((with-statement) $1))
      (statement-sequence ((statement) (list $1))
                          ((statement SC statement-sequence) (cons $1 $3)))
      (compound-statement ((BEGIN statement-sequence END) (list 'comp-stmt $2)))
      (cond-statement ((if-statement) $1)
                      ((case-statement) $1))
      (if-statement ((IF expr THEN statement) (list 'if $2 $4))
                    ((IF expr THEN statement ELSE statement) (list 'if $2 $4 'else $6)))
      (case-statement ((CASE expr OF case-list-element-list END) (list 'case $2 $4))
                      ((CASE expr OF case-list-element-list SC END) (list 'case $2 $4)))
      (case-list-element-list 
       ((case-list-element) (list $1))
       ((case-list-element-list SC case-list-element) (cons $3 $1)))
      (case-list-element ((const-list COLON statement) (list $1 $3)))
      (repetitive-statement ((repeat-statement) $1)
                            ((while-statement) $1)
                            ((for-statement) $1))
      (repeat-statement ((REPEAT statement-sequence UNTIL expr) (list 'repeat $2 $4)))
      (while-statement ((WHILE expr DO statement) (list 'while $2 $4)))
      (for-statement ((FOR ID ASSIGN expr to-downto expr DO statement) (list 'for (tk-val $2) $4 $5 $6 $8)))
      (to-downto ((TO) 'to)
                 ((DOWNTO) 'downto))
      (with-statement ((WITH record-var-list DO statement) (list 'with $2 $4)))
      (record-var-list ((var-access) (list $1))
                       ((var-access COMMA record-var-list) (cons $1 $3)))
      (statement ((labeled simple-statement) (cons $2 $1))
                 ((labeled struct-statement) (cons $2 $1)))
      (labeled (() null)
               ((INT COLON) (list (tk-val $1))))
      
      ;; Miscellanea
      (id-list ((ID) (list (tk-val $1)))
               ((ID COMMA id-list) (cons (tk-val $1) $3)))
      (number ((INT) (tk-val $1))
              ((FLOAT) (tk-val $1)))
      (signed-number ((number) $1)
                     ((sign number) (if (eq? $1 '-) (- $2) $2)))
      (sign ((PLUS) '+)
            ((MINUS) '-)))))
  
  
  (define (run-parser ip)
    (port-count-lines! ip)
    ((spc-parser "") (λ () (spc-lexer ip))))
  (provide run-parser))