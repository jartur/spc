(module spc-parser scheme
  (require parser-tools/yacc
           "spc-lex.ss"
           "spc-structures.ss")
  
  (define (spc-parser source)
    (parser
     (src-pos)
     
     (start program)
     (end EOF)
     
     (error (λ (tok-ok? tok-name tok-value start-pos end-pos)
               (printf "Error at (~s, ~s): Unexpected ~s ~s ~n" 
                       (position-line start-pos) 
                       (position-col start-pos) 
                       tok-name 
                       (tk-val tok-value))))
     
     (tokens keywords delim data eoftk)
     
     (suppress)
     ; (yacc-output "c.y")
     
     (grammar
      
      (program ((program-heading SC block DOT) $3))
      (program-heading ((PROGRAM id) $2)
                       ((PROGRAM id LP id-list RP) (list $2 $4)))
      
      
      ;; Block
      (block ((label-decls 
               const-defs 
               type-defs 
               var-decls 
               proc-func-decls 
               compound-statement) 
              (make-block $1 $2 $3 $4 $5 $6)))
      
      ;; Labels section
      (label-decls (() null)
                   ((LABEL label-list SC) $2))
      (label-list ((INT) (list $1))
                  ((INT COMMA label-list) (cons $1 $3)))
      
      ;; Constants section
      (const-defs (() null)
                  ((CONST const-def-list) $2))
      (const-def-list ((const-def) (list $1))
                      ((const-def const-def-list) (cons $1 $2)))
      (const-def ((id EQ constant SC) (make-constant $1 $3)))
      (constant ((string) $1)
                ((id) $1)
                ((signed-number) $1)
                ((sign id) (list $1 $2)))
      
      ;; Types section
      (type-defs (() null)
                 ((TYPE type-def-list) $2))
      (type-def-list ((type-def) (list $1))
                     ((type-def type-def-list) (cons $1 $2)))
      (type-def ((id EQ type-denoter SC) (make-type-def $1 $3)))
      (type-denoter ((id) $1)
                    ((new-type) $1))
      (new-type ((new-ord-type) $1)
                ((new-struct-type) $1)
                ((new-pointer-type) $1))
      (new-ord-type ((enum-type) $1)
                    ((subrange-type) $1))
      ; Enum type
      (enum-type ((LP id-list RP) (make-enum-type $2)))
      ; Subrange type 
      (subrange-type ((constant DDOT constant) (make-range-type $1 $3)))
      (new-struct-type ((unpacked-struct-type) $1)
                       ((PACKED unpacked-struct-type) 
                        (begin (set-packable-type-packed?! $2 #t) $2)))
      (unpacked-struct-type ((array-type) $1)
                            ((record-type) $1)
                            ((set-type) $1)
                            ((file-type) $1))
      ; Array type
      (array-type ((ARRAY LB ord-type-list RB OF type-denoter) (make-array-type $3 $6)))
      (ord-type-list ((ord-type) (list $1))
                     ((ord-type COMMA ord-type-list) (cons $1 $3)))
      (ord-type ((new-ord-type) $1)
                ((id) $1))
      ; Record type
      (record-type ((RECORD field-list END) $2))
      (field-list (() (make-record-type null null))
                  ((variant-part) (make-record-type null $1))
                  ((variant-part SC) (make-record-type null $1))
                  ((fixed-part) (make-record-type $1 null))
                  ((fixed-part SC) (make-record-type $1 null))
                  ((fixed-part SC variant-part) (make-record-type $1 $3)))
      (fixed-part ((record-section) (list $1))
                  ((fixed-part SC record-section) (cons $3 $1)))
      (record-section ((id-list COLON type-denoter) (make-record-section $1 $3)))
      (variant-part ((CASE variant-selector OF variant-list*) (make-variant-part $2 $4)))
      (variant-list* ((variant-list) $1)
                     ((variant-list SC) $1))
      (variant-list ((variant) (list $1))
                    ((variant-list SC variant) (cons $3 $1)))
      (variant ((const-list COLON LP field-list RP) (make-variant $1 $4)))
      (const-list ((constant) (list $1))
                  ((constant COMMA const-list) (cons $1 $3)))
      (variant-selector ((id) $1)
                        ((id COLON id) (make-variant-selector $1 $3)))
      ; Set type
      (set-type ((SET OF ord-type) (make-set-type $3)))
      ; File type
      (file-type ((FILE OF type-denoter) (make-file-type $3)))
      ; Pointer type
      (new-pointer-type ((CARET id) (make-pointer-type $2)))
      
      ;; Var section
      (var-decls (() null)
                 ((VAR var-decl-list) $2))
      (var-decl-list ((var-decl) (list $1))
                     ((var-decl var-decl-list) (cons $1 $2)))
      (var-decl ((id-list COLON type-denoter SC) (make-var-decl $1 $3)))
      (var-access ((id) (make-var-access $1 null))
                  ((id var-access-rest-list) (make-var-access $1 $2)))
      (var-access-rest-list ((var-access-rest) (list $1))
                            ((var-access-rest var-access-rest-list) (cons $1 $2)))
      (var-access-rest ((LB expr-list RB) (make-var-accessor-index $2))
                       ((DOT id) (make-var-accessor-dot $2))
                       ((CARET) (make-var-accessor-pointer)))
      
      ;; Procedures and Functions declarations
      (proc-func-decls (() null)
                       ((proc-decl proc-func-decls) (cons $1 $2))
                       ((func-decl proc-func-decls) (cons $1 $2)))
      (proc-decl ((proc-heading SC id) (make-proc-decl $1 $3))
                 ((proc-heading SC block) (make-proc-decl $1 $3)))
      (proc-heading ((PROCEDURE id formal-parameter-list) (make-proc-heading $2 $3)))
      (formal-parameter-list (() null)
                             ((LP formal-parameter-section-list RP) $2))
      (formal-parameter-section-list ((formal-parameter-section) (list $1))
                                     ((formal-parameter-section SC formal-parameter-section-list) (cons $1 $3)))
      (formal-parameter-section ((value-parameter-spec) $1)
                                ((var-parameter-spec) $1)
                                ((proc-heading) $1)
                                ((func-heading) $1)
                                ((conformant-array-parameter-spec) $1))
      (value-parameter-spec ((id-list COLON id) (make-value-parameters $1 $3)))
      (var-parameter-spec ((VAR id-list COLON id) (make-var-parameters $2 $4)))
      (conformant-array-parameter-spec ((value-conf-array-spec) $1)
                                       ((var-conf-array-spec) $1))
      (value-conf-array-spec ((id-list COLON conf-array-schema) (make-value-array-parameters $1 $3)))
      (var-conf-array-spec ((VAR id-list COLON conf-array-schema) (make-var-array-parameters $2 $4)))
      (conf-array-schema ((packed-conf-array-schema) $1)
                         ((unpacked-conf-array-schema) $1))
      (packed-conf-array-schema ((PACKED ARRAY LB index-type-spec RB OF id) 
                                 (make-packed-array-schema $4 $7)))
      (unpacked-conf-array-schema 
       ((ARRAY LB index-type-spec-list RB OF unpacked-conf-array-schema-specifier)
        (make-unpacked-array-schema $3 $6)))
      (unpacked-conf-array-schema-specifier ((id) $1)
                                            ((conf-array-schema) $1))
      (index-type-spec-list ((index-type-spec) (list $1))
                            ((index-type-spec SC index-type-spec-list) (cons $1 $3)))
      (index-type-spec ((id DDOT id COLON id) (make-index-type-spec $1 $3 $5)))
      (func-decl ((func-heading SC id) (list 'func $1 $3))
                 ((func-heading SC block) (list 'func $1 $3))
                 ((func-id SC block) (list 'func $1 $3)))
      (func-heading ((FUNCTION id formal-parameter-list COLON id) (make-func-heading $2 $3 $5)))
      (func-id ((FUNCTION id) $2))
      
      ;; Expressions
      (expr-list ((expr) (list $1))
                 ((expr COMMA expr-list) (cons $1 $3)))
      (factor ((id var-access-rest) (make-factor-access $1 $2))
              ((id LP expr-list RP) (make-factor-call $1 $3))
              ((unsigned-const) $1)
              ((set-constructor) $1)
              ((LP expr RP) $2)
              ((NOT factor) (make-unary-op 'not $2)))
      (expr ((simple-expr)  $1)
            ((simple-expr relop simple-expr) (make-binary-op $2 $1 $3)))
      (simple-expr ((term-list) $1)
                   ((sign term-list) (make-unary-op $1 $2)))
      (term-list ((term) $1)
                 ((term addop term-list) (make-binary-op $2 $1 $3)))
      (term ((factor) $1)
            ((factor multop term) (make-binary-op $2 $1 $3)))
      (unsigned-const ((number) $1)
                      ((string) $1)
                      ((id) $1)
                      ((NIL) 'nil))
      (set-constructor ((LB member-designator-list RB) (make-set-constructor $2))
                       ((LB RB) (make-set-constructor null)))
      (member-designator-list ((member-designator) (list $1))
                              ((member-designator COMMA member-designator-list) (cons $1 $3)))
      (member-designator ((expr) (make-member-designator $1 null))
                         ((expr DDOT expr) (make-member-designator $1 $3)))
      (multop ((AST) '*)
              ((SLASH) '/)
              ((DIV) 'div)
              ((MOD) 'mod)
              ((AND) 'and))
      (addop ((PLUS) '+)
             ((MINUS) '-)
             ((OR) 'or))
      (relop ((EQ) '=)
             ((NOTEQ) '<>)
             ((LT) '<)
             ((GT) '>)
             ((LEQ) '<=)
             ((GEQ) '>=)
             ((IN) 'in))
      
      ;; Statements
      (simple-statement (() null)
                        ((assign-statement) $1)
                        ((proc-statement) $1)
                        ((goto-statement) $1))
      
      (assign-statement ((var-access ASSIGN expr) (make-assignment $1 $3)))
      (goto-statement ((GOTO int) (make-goto $2)))
      (proc-statement-arg ((expr) (make-proc-arg $1 null null))
                          ((expr COLON expr) (make-proc-arg $1 $3 null))
                          ((expr COLON expr COLON expr) (make-proc-arg $1 $3 $5)))
      (proc-statement-arg-list 
       ((proc-statement-arg) (list $1))
       ((proc-statement-arg COMMA proc-statement-arg-list) (cons $1 $3)))
      (proc-statement ((id) (make-proc-statement $1 null))
                      ((id LP proc-statement-arg-list RP) (make-proc-statement $1 $3)))
      (struct-statement ((compound-statement) $1)
                        ((cond-statement) $1)
                        ((repetitive-statement) $1)
                        ((with-statement) $1))
      (statement-sequence ((statement) (list $1))
                          ((statement SC statement-sequence) (cons $1 $3)))
      (compound-statement ((BEGIN statement-sequence END) (list 'comp-stmt $2)))
      (cond-statement ((if-statement) $1)
                      ((case-statement) $1))
      (if-statement ((IF expr THEN statement) (list 'if $2 $4))
                    ((IF expr THEN statement ELSE statement) (list 'if $2 $4 'else $6)))
      (case-statement ((CASE expr OF case-list-element-list END) (list 'case $2 $4))
                      ((CASE expr OF case-list-element-list SC END) (list 'case $2 $4)))
      (case-list-element-list 
       ((case-list-element) (list $1))
       ((case-list-element-list SC case-list-element) (cons $3 $1)))
      (case-list-element ((const-list COLON statement) (list $1 $3)))
      (repetitive-statement ((repeat-statement) $1)
                            ((while-statement) $1)
                            ((for-statement) $1))
      (repeat-statement ((REPEAT statement-sequence UNTIL expr) (list 'repeat $2 $4)))
      (while-statement ((WHILE expr DO statement) (list 'while $2 $4)))
      (for-statement ((FOR id ASSIGN expr to-downto expr DO statement) (list 'for $2 $4 $5 $6 $8)))
      (to-downto ((TO) 'to)
                 ((DOWNTO) 'downto))
      (with-statement ((WITH record-var-list DO statement) (list 'with $2 $4)))
      (record-var-list ((var-access) (list $1))
                       ((var-access COMMA record-var-list) (cons $1 $3)))
      (statement ((labeled simple-statement) (cons $2 $1))
                 ((labeled struct-statement) (cons $2 $1)))
      (labeled (() null)
               ((int COLON) (list $1)))
      
      ;; Miscellanea
      (id-list ((id) (list $1))
               ((id COMMA id-list) (cons $1 $3)))
      (number ((int) $1)
              ((FLOAT) (make-pos-token (tk-val $1) (tk-lexeme $1) (position-col $1-start-pos) (position-line $1-start-pos))))
      (signed-number ((number) $1)
                     ((sign number) (let ([f (if (eq? $1 '-) - +)])
                                      (make-pos-token
                                       (f (pos-token-val $2))
                                       (string-append (symbol->string $1) (pos-token-lex $2))
                                       (pos-token-col $2)
                                       (pos-token-line $2)))))
      (sign ((PLUS) '+)
            ((MINUS) '-))
      
      ;; Terminals. Make them nonterminals to get the right structures as return values
      (id ((ID) (make-pos-token (tk-val $1) (tk-lexeme $1) (position-col $1-start-pos) (position-line $1-start-pos))))
      (int ((INT) (make-pos-token (tk-val $1) (tk-lexeme $1) (position-col $1-start-pos) (position-line $1-start-pos))))
      (string ((STRING) (make-pos-token (tk-val $1) (tk-lexeme $1) (position-col $1-start-pos) (position-line $1-start-pos))))))) 
  
  
  (define (run-parser ip)
    (port-count-lines! ip)
    ((spc-parser "") (λ () (spc-lexer ip))))
  (provide run-parser))
