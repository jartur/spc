#lang scheme

  (require parser-tools/lex
           (prefix-in : parser-tools/lex-sre)
           parser-tools/yacc)
  
  (define-tokens data (INT FLOAT STRING ID))
  (define-tokens delim (LP RP LB RB ASSIGN EQ GT LT GEQ LEQ CARET DOT DDOT AST PLUS MINUS SLASH COMMA COLON SC NOTEQ))
  (define-tokens keywords (AND ARRAY BEGIN CASE CONST DIV DO DOWNTO ELSE END FILE FOR FUNCTION GOTO IF IN LABEL MOD NIL NOT OF OR PACKED PROCEDURE PROGRAM RECORD REPEAT SET THEN TO TYPE UNTIL VAR WHILE WITH))
  (define-empty-tokens eoftk (EOF))
  
  (define-struct tk (lexeme val))
  
  (define spc-lexer
    (lexer-src-pos
     ;; Comments
     ((:or whitesp comment) (return-without-pos (spc-lexer input-port)))
     
     ;; EOF
     ((eof) 'EOF)
     
     ;; Symbols
     ((:: #\: #\=) (make-kw-tk token-ASSIGN lexeme))
     ((:: #\> #\=) (make-kw-tk token-GEQ lexeme))
     ((:: #\< #\=) (make-kw-tk token-LEQ lexeme))
     ((:: #\. #\.) (make-kw-tk token-DDOT lexeme))
     ((:: #\< #\>) (make-kw-tk token-NOTEQ lexeme))
     (#\> (make-kw-tk token-GT lexeme))
     (#\= (make-kw-tk token-EQ lexeme))
     (#\; (make-kw-tk token-SC lexeme))
     (#\: (make-kw-tk token-COLON lexeme))
     (#\, (make-kw-tk token-COMMA lexeme))
     (#\/ (make-kw-tk token-SLASH lexeme))
     (#\- (make-kw-tk token-MINUS lexeme))
     (#\+ (make-kw-tk token-PLUS lexeme))
     (#\* (make-kw-tk token-AST lexeme))
     (#\. (make-kw-tk token-DOT lexeme))
     (#\^ (make-kw-tk token-CARET lexeme))
     (#\< (make-kw-tk token-LT lexeme))
     (#\( (make-kw-tk token-LP lexeme))
     (#\) (make-kw-tk token-RP lexeme))
     (#\[ (make-kw-tk token-LB lexeme))
     (#\] (make-kw-tk token-RB lexeme))
     
     ;; Keywords
     ((:: a n d) (make-kw-tk token-AND lexeme))
     ((:: a r r a y) (make-kw-tk token-ARRAY lexeme))
     ((:: b e g i n) (make-kw-tk token-BEGIN lexeme))
     ((:: c a s e) (make-kw-tk token-CASE lexeme))
     ((:: c o n s t) (make-kw-tk token-CONST lexeme))
     ((:: d i v) (make-kw-tk token-DIV lexeme))
     ((:: d o) (make-kw-tk token-DO lexeme))
     ((:: d o w n t o) (make-kw-tk token-DOWNTO lexeme))
     ((:: e l s e) (make-kw-tk token-ELSE lexeme))
     ((:: e n d) (make-kw-tk token-END lexeme))
     ((:: f i l e) (make-kw-tk token-FILE lexeme))
     ((:: f o r) (make-kw-tk token-FOR lexeme))
     ((:: f u n c t i o n) (make-kw-tk token-FUNCTION lexeme))
     ((:: g o t o) (make-kw-tk token-GOTO lexeme))
     ((:: i f) (make-kw-tk token-IF lexeme))
     ((:: i n) (make-kw-tk token-IN lexeme))
     ((:: l a b e l) (make-kw-tk token-LABEL lexeme))
     ((:: m o d) (make-kw-tk token-MOD lexeme))
     ((:: n i l) (make-kw-tk token-NIL lexeme))
     ((:: n o t) (make-kw-tk token-NOT lexeme))
     ((:: o f) (make-kw-tk token-OF lexeme))
     ((:: o r) (make-kw-tk token-OR lexeme))
     ((:: p a c k e d) (make-kw-tk token-PACKED lexeme))
     ((:: p r o c e d u r e) (make-kw-tk token-PROCEDURE lexeme))
     ((:: p r o g r a m) (make-kw-tk token-PROGRAM lexeme))
     ((:: r e c o r d) (make-kw-tk token-RECORD lexeme))
     ((:: r e p e a t) (make-kw-tk token-REPEAT lexeme))
     ((:: s e t) (make-kw-tk token-SET lexeme))
     ((:: t h e n) (make-kw-tk token-THEN lexeme))
     ((:: t o) (make-kw-tk token-TO lexeme))
     ((:: t y p e) (make-kw-tk token-TYPE lexeme))
     ((:: u n t i l) (make-kw-tk token-UNTIL lexeme))
     ((:: v a r) (make-kw-tk token-VAR lexeme))
     ((:: w h i l e) (make-kw-tk token-WHILE lexeme))
     ((:: w i t h) (make-kw-tk token-WITH lexeme))
     
     ;; Id
     ((:: letter (:* (:or letter digit))) (make-kw-tk token-ID lexeme))
     
     ;; Numbers & strings
     ((:: int (:or (:: #\. digitseq (:? exp)) exp)) 
      (token-FLOAT (make-tk lexeme (string->number lexeme))))
     (int 
      (token-INT (make-tk lexeme (string->number lexeme))))
     ((:: #\' (:* (:or (:~ #\') (:: #\' #\'))) #\') 
      (token-STRING (make-tk lexeme (clean-string lexeme))))))
  
  (define (make-kw-tk tok lex)
    (tok (make-tk lex (string-upcase lex))))
  
  (define (clean-string str)
    (list->string
     (let loop ([l (cdr (string->list str))])
       (if (null? (cdr l))
           null
           (if (and (char=? (cadr l) #\') (char=? (car l) #\'))
               (loop (cdr l))
               (cons (car l) (loop (cdr l))))))))
  
  
  
  (define-lex-abbrevs
    (digit (:/ #\0 #\9))
    (letter (:or (:/ #\a #\z) (:/ #\A #\Z)))
    (whitesp (:or #\newline #\return #\tab #\space #\vtab))
    (comment-end (:or #\} "*)"))
    (comment (:: (:or #\{ "(*") (complement (:: any-string comment-end any-string)) comment-end))
    (digitseq (:+ digit))
    (sign (:or #\+ #\-))
    (int (:: digitseq))
    (exp (:: (:or #\e #\E) (:? sign) int))
    
    (a (:or #\a #\A))
    (b (:or #\b #\B))
    (c (:or #\c #\C))
    (d (:or #\d #\D))
    (e (:or #\e #\E))
    (f (:or #\f #\F))
    (g (:or #\g #\G))
    (h (:or #\h #\H))
    (i (:or #\i #\I))
    (j (:or #\j #\J))
    (k (:or #\k #\K))
    (l (:or #\l #\L))
    (m (:or #\m #\M))
    (n (:or #\n #\N))
    (o (:or #\o #\O))
    (p (:or #\p #\P))
    (q (:or #\q #\Q))
    (r (:or #\r #\R))
    (s (:or #\s #\S))
    (t (:or #\t #\T))
    (u (:or #\u #\U))
    (v (:or #\v #\V))
    (w (:or #\w #\W))
    (x (:or #\x #\X))
    (y (:or #\y #\Y))
    (z (:or #\z #\Z)))
  
  (define (gen-tokens lst)
    (define (spl str)
      (map (λ (x) (string->symbol (string (char-downcase x)))) (string->list str)))
    (let loop ([l lst])
      (if (null? l)
          null
          (let ([s (symbol->string (car l))])
            (cons (list (cons ':: (spl s)) (list 'make-kw-tk (string->symbol (string-append "token-" (string-upcase s))) 'lexeme)) (loop (cdr l)))))))
  
  (define (genn)
    (let loop ([c #\a])
      (if (char=? c (integer->char (+ 1 (char->integer #\z))))
          null
          (cons (list (string->symbol (string c)) (list ':or c (char-upcase c))) (loop (integer->char (+ 1 (char->integer c))))))))
  
  
  (define (spc-parser source)
    (parser
     (src-pos)
     
     (start program)
     (end EOF)
     
     (error (λ (tok-ok? tok-name tok-value start-pos end-pos)
              (printf "Error at (~s, ~s): Unexpected ~s ~s ~n" (position-line start-pos) (position-col start-pos) tok-name (tk-val tok-value))))
     
     (tokens keywords delim data eoftk)
     
     (suppress)
    ; (yacc-output "c.y")
     
     (grammar
      
      (program ((program-heading SC block DOT) (list 'program $1 $3)))
      (program-heading ((PROGRAM ID) (tk-val $2))
                       ((PROGRAM ID LP id-list RP) (list (tk-val $2) $4)))
      
      
      ;; Block
      (block ((label-decls const-defs type-defs var-decls proc-func-decls compound-statement) (list 'block $1 $2 $3 $4 $5 $6)))
      
      ;; Labels section
      (label-decls (() null)
                   ((LABEL label-list SC) (list 'labels $2)))
      (label-list ((INT) (list (tk-val $1)))
                  ((INT COMMA label-list) (cons (tk-val $1) $3)))
      
      ;; Constants section
      (const-defs (() null)
                  ((CONST const-def-list) (list 'consts $2)))
      (const-def-list ((const-def) (list $1))
                      ((const-def const-def-list) (cons $1 $2)))
      (const-def ((ID EQ constant SC) (list (tk-val $1) $3)))
      (constant ((STRING) (tk-val $1))
                ((ID) (tk-val $1))
                ((signed-number) $1)
                ((sign ID) (list $1 (tk-val $2))))
      
      ;; Types section
      (type-defs (() null)
                 ((TYPE type-def-list) (list 'types $2)))
      (type-def-list ((type-def) (list $1))
                     ((type-def type-def-list) (cons $1 $2)))
      (type-def ((ID EQ type-denoter SC) (list (tk-val $1) $3)))
      (type-denoter ((ID) (tk-val $1))
                    ((new-type) $1))
      (new-type ((new-ord-type) $1)
                ((new-struct-type) $1)
                ((new-pointer-type) $1))
      (new-ord-type ((enum-type) $1)
                    ((subrange-type) $1))
      ; Enum type
      (enum-type ((LP id-list RP) $2))
      ; Subrange type
      (subrange-type ((constant DDOT constant) (list 'range $1 $3)))
      (new-struct-type ((unpacked-struct-type) $1)
                       ((PACKED unpacked-struct-type) (list 'packed $2)))
      (unpacked-struct-type ((array-type) $1)
                            ((record-type) $1)
                            ((set-type) $1)
                            ((file-type) $1))
      ; Array type
      (array-type ((ARRAY LB ord-type-list RB OF type-denoter) (list 'array $3 $6)))
      (ord-type-list ((ord-type) (list $1))
                     ((ord-type COMMA ord-type-list) (cons $1 $3)))
      (ord-type ((new-ord-type) $1)
                ((ID) (tk-val $1)))
      ; Record type
      (record-type ((RECORD field-list END) (list 'record $2)))
      (field-list (() null)
                  ((variant-part) $1)
                  ((variant-part SC) $1)
                  ((fixed-part) $1)
                  ((fixed-part SC) $1)
                  ((fixed-part SC variant-part) (list $1 $3)))
      (fixed-part ((record-section) (list $1))
                  ((fixed-part SC record-section) (cons $3 $1)))
      (record-section ((id-list COLON type-denoter) (list $1 $3)))
      (variant-part ((CASE variant-selector OF variant-list*) (list 'variant $2 $4)))
      (variant-list* ((variant-list) $1)
                     ((variant-list SC) $1))
      (variant-list ((variant) (list $1))
                    ((variant-list SC variant) (cons $3 $1)))
      (variant ((const-list COLON LP field-list RP) (list $1 $4)))
      (const-list ((constant) (list $1))
                  ((constant COMMA const-list) (cons $1 $3)))
      (variant-selector ((ID) (tk-val $1))
                        ((ID COLON ID) (list (tk-val $1) (tk-val $3))))
      ; Set type
      (set-type ((SET OF ord-type) (list 'set $3)))
      ; File type
      (file-type ((FILE OF type-denoter) (list 'file $3)))
      ; Pointer type
      (new-pointer-type ((CARET ID) (list '^ $2)))
      
      ;; Var section
      (var-decls (() null)
                 ((VAR var-decl-list) (list 'vars $2)))
      (var-decl-list ((var-decl) (list $1))
                     ((var-decl var-decl-list) (cons $1 $2)))
      (var-decl ((id-list COLON type-denoter SC) (list $1 $3)))
      (var-access ((ID) (tk-val $1))
                  ((ID var-access-rest-list) (list (tk-val $1) $2)))
      (var-access-rest-list ((var-access-rest) (list $1))
                            ((var-access-rest var-access-rest-list) (cons $1 $2)))
      (var-access-rest ((LB expr-list RB) $2)
                       ((DOT ID) (list 'dot (tk-val $2)))
                       ((CARET) 'caret))
      
      ;; Procedures and Functions declarations
      (proc-func-decls (() null)
                       ((proc-decl proc-func-decls) (cons $1 $2))
                       ((func-decl proc-func-decls) (cons $1 $2)))
      (proc-decl ((proc-heading SC ID) (list 'proc $1 (tk-val $3)))
                 ((proc-heading SC block) (list 'proc $1 $3)))
      (proc-heading ((PROCEDURE ID formal-parameter-list) (list (tk-val $2) $3)))
      (formal-parameter-list (() null)
                             ((LP formal-parameter-section-list RP) $2))
      (formal-parameter-section-list ((formal-parameter-section) (list $1))
                                     ((formal-parameter-section SC formal-parameter-section-list) (cons $1 $3)))
      (formal-parameter-section ((value-parameter-spec) $1)
                                ((var-parameter-spec) $1)
                                ((proc-heading) $1)
                                ((func-heading) $1)
                                ((conformant-array-parameter-spec) $1))
      (value-parameter-spec ((id-list COLON ID) (list $1 (tk-val $3))))
      (var-parameter-spec ((VAR id-list COLON ID) (list 'var $2 (tk-val $4))))
      (conformant-array-parameter-spec ((value-conf-array-spec) $1)
                                       ((var-conf-array-spec) $1))
      (value-conf-array-spec ((id-list COLON conf-array-schema) (list $1 $3)))
      (var-conf-array-spec ((VAR id-list COLON conf-array-schema) (list 'var $2 $4)))
      (conf-array-schema ((packed-conf-array-schema) $1)
                         ((unpacked-conf-array-schema) $1))
      (packed-conf-array-schema ((PACKED ARRAY LB index-type-spec RB OF ID) (list 'packed $4 (tk-val $7))))
      (unpacked-conf-array-schema 
       ((ARRAY LB index-type-spec-list RB OF unpacked-conf-array-schema-specifier)
        (list 'array $3 $6)))
      (unpacked-conf-array-schema-specifier ((ID) (tk-val $1))
                                            ((conf-array-schema) $1))
      (index-type-spec-list ((index-type-spec) (list $1))
                            ((index-type-spec SC index-type-spec-list) (cons $1 $3)))
      (index-type-spec ((ID DDOT ID COLON ID) (list 'index (tk-val $1) (tk-val $3) (tk-val $5))))
      (func-decl ((func-heading SC ID) (list 'func $1 (tk-val $3)))
                 ((func-heading SC block) (list 'func $1 $3))
                 ((func-id SC block) (list 'func $1 $3)))
      (func-heading ((FUNCTION ID formal-parameter-list COLON ID) (list (tk-val $2) $3 (tk-val $5))))
      (func-id ((FUNCTION ID) (tk-val $2)))
      
      ;; Expressions
      (expr-list ((expr) (list $1))
                 ((expr COMMA expr-list) (cons $1 $3)))
      (factor ((ID var-access-rest) (list (tk-val $1) $2))
              ((ID LP expr-list RP) (list (tk-val $1) $3))
              ((unsigned-const) $1)
              ((set-constructor) $1)
              ((LP expr RP) $2)
              ((NOT factor) (list 'not $2)))
      (expr ((simple-expr)  $1)
            ((simple-expr relop simple-expr) (list $2 $1 $3)))
      (simple-expr ((term-list) $1)
                   ((sign term-list) (list $1 $2)))
      (term-list ((term) $1)
                 ((term addop term-list) (list $2 $1 $3)))
      (term ((factor) $1)
            ((factor multop term) (list $2 $1 $3)))
      (unsigned-const ((number) $1)
                      ((STRING) (tk-val $1))
                      ((ID) (tk-val $1))
                      ((NIL) 'nil))
      (set-constructor ((LB member-designator-list RB) $2)
                       ((LB RB) null))
      (member-designator-list ((member-designator) (list $1))
                              ((member-designator COMMA member-designator-list) (cons $1 $3)))
      (member-designator ((expr) $1)
                         ((expr DDOT expr) (list $1 $3)))
      (multop ((AST) '*)
              ((SLASH) '/)
              ((DIV) 'div)
              ((MOD) 'mod)
              ((AND) 'and))
      (addop ((PLUS) '+)
             ((MINUS) '-)
             ((OR) 'or))
      (relop ((EQ) '=)
             ((NOTEQ) '<>)
             ((LT) '<)
             ((GT) '>)
             ((LEQ) '<=)
             ((GEQ) '>=)
             ((IN) 'in))
      
      ;; Statements
      (simple-statement (() null)
                        ((assign-statement) $1)
                        ((proc-statement) $1)
                        ((goto-statement) $1))
      
      (assign-statement ((var-access ASSIGN expr) (list ':= $1 $3)))
      (goto-statement ((GOTO INT) (list 'goto (tk-val $2))))
      (proc-statement-arg ((expr) $1)
                          ((expr COLON expr) (list $1 $3))
                          ((expr COLON expr COLON expr) (list $1 $3 $5)))
      (proc-statement-arg-list 
       ((proc-statement-arg) (list $1))
       ((proc-statement-arg COMMA proc-statement-arg-list) (cons $1 $3)))
      (proc-statement ((ID) (tk-val $1))
                      ((ID LP proc-statement-arg-list RP) (list (tk-val $1) $3)))
      (struct-statement ((compound-statement) $1)
                        ((cond-statement) $1)
                        ((repetitive-statement) $1)
                        ((with-statement) $1))
      (statement-sequence ((statement) (list $1))
                          ((statement SC statement-sequence) (cons $1 $3)))
      (compound-statement ((BEGIN statement-sequence END) (list 'comp-stmt $2)))
      (cond-statement ((if-statement) $1)
                      ((case-statement) $1))
      (if-statement ((IF expr THEN statement) (list 'if $2 $4))
                    ((IF expr THEN statement ELSE statement) (list 'if $2 $4 'else $6)))
      (case-statement ((CASE expr OF case-list-element-list END) (list 'case $2 $4))
                      ((CASE expr OF case-list-element-list SC END) (list 'case $2 $4)))
      (case-list-element-list 
       ((case-list-element) (list $1))
       ((case-list-element-list SC case-list-element) (cons $3 $1)))
      (case-list-element ((const-list COLON statement) (list $1 $3)))
      (repetitive-statement ((repeat-statement) $1)
                            ((while-statement) $1)
                            ((for-statement) $1))
      (repeat-statement ((REPEAT statement-sequence UNTIL expr) (list 'repeat $2 $4)))
      (while-statement ((WHILE expr DO statement) (list 'while $2 $4)))
      (for-statement ((FOR ID ASSIGN expr to-downto expr DO statement) (list 'for (tk-val $2) $4 $5 $6 $8)))
      (to-downto ((TO) 'to)
                 ((DOWNTO) 'downto))
      (with-statement ((WITH record-var-list DO statement) (list 'with $2 $4)))
      (record-var-list ((var-access) (list $1))
                       ((var-access COMMA record-var-list) (cons $1 $3)))
      (statement ((labeled simple-statement) (cons $2 $1))
                 ((labeled struct-statement) (cons $2 $1)))
      (labeled (() null)
               ((INT COLON) (list (tk-val $1))))
      
      ;; Miscellanea
      (id-list ((ID) (list (tk-val $1)))
               ((ID COMMA id-list) (cons (tk-val $1) $3)))
      (number ((INT) (tk-val $1))
              ((FLOAT) (tk-val $1)))
      (signed-number ((number) $1)
                     ((sign number) (if (eq? $1 '-) (- $2) $2)))
      (sign ((PLUS) '+)
            ((MINUS) '-)))))
  
  
     (define (run-parser ip)
       (port-count-lines! ip)
       ((spc-parser "") (λ () (spc-lexer ip))))
     
     (run-parser (open-input-file "test.pas"))
 ; (provide spc-lexer data delim keywords eoftk INT FLOAT STRING ID LP RP LB RB ASSIGN EQ GT LT GEQ LEQ CARET DOT DDOT AST PLUS MINUS SLASH COMMA COLON SC NOTEQ AND ARRAY BEGIN CASE CONST DIV DO DOWNTO ELSE END FILE FOR FUNCTION GOTO IF IN LABEL MOD NIL NOT OF OR PACKED PROCEDURE PROGRAM RECORD REPEAT SET THEN TO TYPE UNTIL VAR WHILE WITH EOF tk-lexeme tk-val)